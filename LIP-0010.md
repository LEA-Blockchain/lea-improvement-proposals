* **LIP: 10**
* **Layer: Application**
* **Title: LEA Transaction Manifest (LTM)**
* **Author: Allwin Ketnawang**
* **Created: 2025-07-15**
* **Requires: 7**
* **Status: Proposed**

## Abstract

This LIP proposes the LEA Transaction Manifest (LTM), a standardized, declarative JSON format for defining LEA transactions. The LTM schema is designed to abstract away the complexities of binary serialization, allowing developers and users to define complex transactions in a human-readable and reusable manner. It provides a robust system for sourcing data dynamically from the local file system, external commands, and other data structures. The primary goal of LTM is to make transaction creation simpler, safer, and more transparent, separating the definition of a transaction's data from the logic of its binary encoding.

## Motivation

The process of creating a valid LEA transaction, as defined in LIP-7, requires precise binary encoding using the Simple Compact Transaction Protocol (SCTP). Constructing this binary stream programmatically is a low-level task that is verbose, error-prone, and requires custom scripting for each new type of transaction. This approach tightly couples the transaction's data with the application logic, making it difficult to manage, reuse, or audit transaction definitions.

The LEA Transaction Manifest (LTM) introduces a declarative layer that solves this problem. By defining a transaction in a structured JSON format, users can clearly specify all its components (such as signers, gas parameters, and contract invocations) without writing any encoding logic. The LTM format is designed to be processed by a build tool that handles all the underlying complexities of data resolution, SCTP encoding, hashing, and signing. This separation of concerns dramatically simplifies the user experience, reduces the risk of malformed transactions, and promotes the creation of reusable transaction templates.

## Specification

A LEA Transaction Manifest is a JSON file that adheres to the following structure. The file must be parsed by a tool that can safely handle large integers to prevent precision loss.

### 1. Top-Level Structure

The LTM is a single JSON object with the following root fields:

| Field | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `sequence` | Number or String | Yes | The sequence number (nonce) for the fee-paying signer. |
| `feePayer` | String | Yes | The name of the signer who will pay the transaction fees. Must match a key in the `signers` object. |
| `gasLimit` | Number or String | Yes | The maximum gas units the transaction can consume. |
| `gasPrice` | Number or String | Yes | The price per gas unit. |
| `outputFile` | String | No | The file path where the final binary transaction will be written. If omitted when using the CLI, the binary output is written to `stdout`. This field is ignored when used as a module. |
| `constants` | Object | No | An object defining reusable values that can be referenced elsewhere in the manifest. |
| `signers` | Object | Yes | An object defining the one or more signers for the transaction. |
| `invocations` | Array | Yes | An array of one or more invocation objects. |

### 2. `signers` Object

The `signers` object contains one or more key-value pairs, where each key is a unique, user-defined name for the signer. This name is used to reference the signer in the `feePayer` field or in `$signer` placeholders.

The value associated with each signer name **MUST** be a string that uses a placeholder to dynamically load a keyset, or, when used as a module, a direct JavaScript array. The loaded keyset **MUST** conform to the format defined in **LIP-12: LEA Keyset File Format**.

**Example:**
```json
"signers": {
  "main": "$file(./main-keyset.json)",
  "secondary": "$json(./all-my-secrets.json#wallets.secondary)",
  "ephemeral": "$exec(./generate-temporary-keys.sh)"
}
```

When used programmatically as a module, a direct array can be provided:
```javascript
const myKeyset = [
  [ 1, 2, 3, ... ], // Ed25519 sk
  [ [ 101, 102, ... ], [ 201, 202, ... ] ] // SPHINCS+ sk, pk
];

const ltmObject = {
  // ...
  signers: {
    main: myKeyset
  }
  // ...
};
```

### 3. `constants` Object

This optional top-level object allows you to define key-value pairs for reusable values. These constants can be referenced in other parts of the manifest using the `$const()` placeholder. This is useful for reducing repetition and improving maintainability.

**Example:**
```json
"constants": {
  "tokenProgram": "a1b2c3d4e5f6...",
  "USER_REGISTRATION_ID": 5
}
```

### 4. `invocations` Array

The `invocations` array contains one or more objects, each representing a single call to a smart contract.

| Field | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `targetAddress` | String | Yes | The 32-byte hex address of the target contract. Can be a literal or use a placeholder. |
| `instructions` | Array | Yes | An array defining the instruction payload to be sent to the target. |

### 5. `instructions` Array

This array defines the sequence of data fields that constitute the instruction payload. Each element in the array is an object with a **single key**, where the key is the SCTP type (e.g., `vector`, `uleb`) and the value is the data to be encoded.

**Example:**
```json
"instructions": [
  { "uleb": "$const(USER_REGISTRATION_ID)" },
  { "vector": "$signer(mainAccount.ed25519Pk)" },
  { "uint64": "18446744073709551615" }
]
```

### 6. Placeholder Syntax for Dynamic Data

To enable dynamic data sourcing, LTM values can use a function-like placeholder syntax: `$<source>(<value>)`. A build tool must resolve these placeholders before encoding the transaction.

| Placeholder Syntax | Example | Description |
| :--- | :--- | :--- |
| `$const(<key>)` | `"$const(tokenProgram)"` | Retrieves a value from the `constants` object. |
| `$signer(<name>.<key>)` | `"$signer(mainAccount.address)"` | Retrieves a derived value from a named signer. Valid keys are `ed25519Pk`, `sphincsPk`, and `address`. |
| `$file(<path>)` | `"$file(./payload.bin)"` | Reads the raw binary content of a file. Used for `vector` types. |
| `$hex(<hex_string>)` | `"$hex(deadbeef0123)"` | Interprets a literal string as a hexadecimal byte sequence. Used for `vector` types. |
| `$json(<path>#<json_path>)` | `"$json(./cfg.json#user.id)"` | Parses a JSON file and extracts the value at the given path (using `#` as a separator). The result can be a number, string, boolean, or BigInt. |
| `$exec(<cmd>[#<fmt>[#<path>]])`| See table below. | Executes a shell command and captures its stdout. The optional `fmt` specifier determines how to interpret the output. |

#### `$exec` Format Specifiers

| Format | Example | Description |
| :--- | :--- | :--- |
| `bin` (default) | `$exec(./gen-data)` | Treats stdout as a raw binary stream. |
| `hex` | `$exec(./gen-hex#hex)` | Expects stdout to be a hex-encoded string. |
| `json` | `$exec(curl api/n#json#nonce)` | Expects stdout to be JSON. The `#` path is used to extract a specific value. |

### 7. General Schema Rules

#### Field Naming and Case Sensitivity

All field names defined in this specification are **case-sensitive** and **MUST** be written in `camelCase`. An LTM parsing tool must reject any manifest that uses a different case or format (e.g., `snake_case` or `kebab-case`) for official field names.

#### Comments

JSON does not natively support comments. To allow for inline documentation, any JSON object within an LTM file may include a field with the key `comment`. An LTM tool **MUST** completely ignore this field and its value during processing.

**Example:**
```json
{
  "uleb": 5,
  "comment": "Instruction ID 5 is for user registration."
}
```

### 8. Data Type Handling

- **Literals:** Values without placeholders are treated as literals (e.g., `123`, `"hello"`).
- **Large Integers:** The JSON specification allows for numbers of arbitrary precision. However, many standard parsers (like JavaScript's native `JSON.parse()`) will truncate large integer values, leading to silent data corruption. Therefore, it is a strict requirement that any compliant LTM implementation **MUST** use a parser that preserves the full precision of all numeric literals, converting them to a `BigInt` or an equivalent lossless type. While a compliant tool must handle unquoted large numbers safely, providing them as strings (e.g., `"18446744073709551615"`) remains a recommended best practice to ensure maximum compatibility across different platforms and tools.
- **Programmable Use:** When used as a library, an LTM build tool should provide maximum flexibility by accepting direct JavaScript types for instruction fields. This includes `Uint8Array` for vector types, `BigInt` for large integer types (e.g., `uint64`, `sleb`), and standard `Number` for smaller integer and float types (e.g., `uint32`, `float64`). The tool is responsible for validating that a provided `Number` is within the valid and safe range for its target SCTP type.

### Full Example

```json
{
  "comment": "This transaction registers a new user with a specific username and ID.",
  "sequence": 2,
  "feePayer": "registrar",
  "gasLimit": 500000,
  "gasPrice": 10,
  "outputFile": "./register-user.tx.bin",
  "constants": {
    "contract": "$exec(node ./get-contract-address.js#hex)",
    "registrationId": 1
  },
  "signers": {
    "registrar": {
      "ed25519": {
        "secretKey": "./keys/registrar.ed25519.sk"
      },
      "sphincs": {
        "secretKey": "./keys/registrar.sphincs.sk",
        "publicKey": "./keys/registrar.sphincs.pk"
      }
    }
  },
  "invocations": [
    {
      "targetAddress": "$const(contract)",
      "instructions": [
        {
          "uleb": "$const(registrationId)",
          "comment": "Instruction ID 1 is for registering a new user."
        },
        { "vector": "$json(./user-data.json#profile.username)" },
        { "uint64": "$exec(curl http://localhost:8080/id-service#json#newId)" },
        { "vector": "$signer(registrar.address)" }
      ]
    }
  ]
}
```

## Rationale

The design of the LTM is guided by the principles of clarity, safety, and flexibility.
- **JSON as a Base:** JSON is ubiquitous, human-readable, and supported by virtually all programming languages, making it an ideal foundation.
- **Declarative Approach:** By defining *what* the transaction should contain rather than *how* to build it, the manifest separates concerns. This simplifies the user's task and allows the underlying build tool to be optimized independently.
- **Placeholder System:** A simple, consistent placeholder syntax (`$source(...)`) provides powerful and explicit data sourcing capabilities. This avoids the need for complex templating languages while enabling composition from files, commands, and other data sources.
- **Explicit `exec` Formatting:** Requiring a format specifier for `$exec` (e.g., `#hex`) is a deliberate security choice. It resolves ambiguity between binary and text-based data, preventing silent data corruption and ensuring user intent is preserved.
- **Single-Key Instruction Objects:** Using `{ "type": "value" }` for instructions is concise and less verbose than `{ "type": "type", "value": "value" }`, making the manifest cleaner and easier to read.

## Backwards Compatibility

The LEA Transaction Manifest is a new, additive standard for tooling and application-layer development. It does not propose any changes to the underlying transaction format defined in LIP-7 or any other core protocol rule. Therefore, it introduces no backwards compatibility issues.

## Security Considerations

- **Command Execution (`$exec`):** This is the most significant security consideration. An LTM build tool will execute any command specified in an `$exec` placeholder with the permissions of the user running the tool. Users must be warned to only use LTM files from trusted sources and to only execute trusted scripts. Maliciously crafted manifests could be used to execute arbitrary commands.
- **Safe JSON Parsing:** Implementations of LTM parsers MUST use a library that can safely handle large integers (e.g., `json-bigint` for Node.js) to prevent silent precision loss on 64-bit numbers. Parsers MUST also operate in a strict mode that rejects duplicate keys to prevent malicious or accidental parameter overrides.
- **File System Access:** The `$file` and `$json` placeholders read data from the local file system. While less dangerous than command execution, users should be aware that a manifest can access any file readable by the current user.

## Copyright

This LIP is licensed under the MIT License.
