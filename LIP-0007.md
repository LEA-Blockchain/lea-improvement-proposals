* **LIP: 7**
* **Layer: Application**
* **Title: Standard LEA Transaction Format**
* **Author: Allwin Ketnawang**
* **Created: 2025-07-07**
* **Requires: 6**
* **Status: Proposed**

## Abstract

This LIP defines the official, standardized binary layout for a LEA transaction. The format is built upon the Simple Compact Transaction Protocol (SCTP) primitives defined in LIP-6. It specifies a fixed sequence of fields, including version, sequence number, address vectors, gas parameters, instructions, and dual-signature blocks (Ed25519 and SLH-DSA). This standard ensures that all transactions across the LEA ecosystem are structured consistently, enabling interoperability and deterministic processing.

## Motivation

While LIP-6 defines the low-level data primitives (the "alphabet") for encoding data, it does not define the high-level structure of a transaction (the "grammar"). A standard transaction format is essential for all network participants to interpret, validate, and process transactions in a uniform way. This proposal provides that standard, detailing the exact order, type, and meaning of each field within a transaction. It also specifies the precise method for hashing and signing transactions to ensure cryptographic integrity.

## Specification

All LEA transactions MUST be serialized according to the following structure, using the SCTP encoding types defined in LIP-6.

### Core Type System

The transaction format utilizes a specific subset of the SCTP types:

| SCTP Type ID | Name      | Description                                 |
| ------------ | --------- | ------------------------------------------- |
| `8`          | `ULEB128` | Unsigned variable-length integer            |
| `13`         | `VECTOR`  | Raw byte array with a length prefix         |
| `15`         | `EOF`     | End-of-transaction marker (1 byte: `0x0F`)  |

### LEA Transaction Layout

A transaction is a sequence of the following fields in this exact order:

```plaintext
LEATransaction {
  version:            ULEB128            # Protocol version
  sequence:           ULEB128            # Fee payer's transaction counter

  signedAddresses:    VECTOR             # Flat array of 32-byte addresses that provide signatures
  unsignedAddresses:  VECTOR             # Flat array of 32-byte addresses that do not provide signatures

  gasLimit:           ULEB128            # Maximum gas to be consumed
  gasPrice:           ULEB128            # Price per unit of gas

  instructions:       VECTOR             # A byte vector containing encoded instructions

  ed25519Signatures:  VECTOR             # One 32-byte signature for each entry in signedAddresses
  slhdsaSignatures:   VECTOR             # One 29,792-byte signature for each entry in signedAddresses

  EOF                 Byte (0x0F)        # Marks the absolute end of the transaction
}
```

### Field Constraints and Rules

1.  **Addresses (`signedAddresses`, `unsignedAddresses`):**
    *   Both fields are SCTP `VECTOR`s.
    *   Each address within the vectors is exactly 32 bytes.
    *   The total byte length of each vector MUST be a multiple of 32.
    *   The first address in `signedAddresses` is designated as the **fee payer**.

2.  **Signatures (`ed25519Signatures`, `slhdsaSignatures`):**
    *   The number of signatures in each signature vector MUST be equal to the number of addresses in `signedAddresses`.
    *   `ed25519Signatures` is a `VECTOR` whose length MUST be `count(signedAddresses) * 32`.
    *   `slhdsaSignatures` is a `VECTOR` whose length MUST be `count(signedAddresses) * 29792`.
    *   The signatures in both vectors correspond one-to-one with the addresses in `signedAddresses` by index.

3.  **Instructions:**
    *   The `instructions` field is a single SCTP `VECTOR`. The internal byte sequence of this vector is defined by application-level logic, not by the base transaction protocol.

4.  **Termination:**
    *   Every valid transaction MUST end with a single `EOF` byte (`0x0F`).
    *   No other data, padding, or extension fields are permitted after the `EOF` marker.

### Hashing and Signing Protocol

*   **Hashing:** The transaction hash is the `BLAKE3` digest of the entire transaction byte stream from the `version` field up to and including the `instructions` field. The signature blocks (`ed25519Signatures`, `slhdsaSignatures`) and the final `EOF` marker are **excluded** from the hash.
*   **Signing:** For every address in the `signedAddresses` vector, a corresponding Ed25519 signature and an SLH-DSA signature over the transaction hash must be provided and placed in their respective signature vectors.

## Rationale

*   **Fixed Layout:** A fixed field order simplifies parsing logic and eliminates ambiguity.
*   **SCTP Base:** Building on LIP-6 ensures that the low-level encoding is consistent with the rest of the protocol.
*   **Dual Signatures:** Requiring both Ed25519 and SLH-DSA (a PQC algorithm) signatures provides both high performance for standard validation and long-term security against quantum attacks.
*   **Explicit Vectors:** Using explicit `VECTOR` types for lists of addresses and signatures makes the format robust and simplifies parsing, as the length is declared up-front.
*   **Gas Mechanism:** Including `gasLimit` and `gasPrice` provides a standard mechanism for transaction fee calculation and resource management.

## Backwards Compatibility

This LIP defines a new, foundational application-layer standard. It does not replace a previously defined transaction format LIP. As such, it does not introduce a backwards compatibility break in the LIP process, but its adoption is a mandatory and breaking change for any client or node software wishing to interact with the LEA network, in conjunction with the adoption of LIP-6.

## Security Considerations

*   **Hashing Integrity:** Validators MUST strictly adhere to the specified hashing protocol, ensuring only the correct fields are included in the hash digest. Hashing the signature block would invalidate all signatures.
*   **Signature Verification:** For each address in `signedAddresses`, both the Ed25519 and SLH-DSA signatures must be successfully verified against the transaction hash using the corresponding public key. A failure in either verification invalidates the transaction.
*   **Vector Length Validation:** Parsers MUST validate that the lengths of the `signedAddresses`, `unsignedAddresses`, and signature vectors are multiples of their respective element sizes (32 or 29792). Failure to do so could lead to buffer overflows or incorrect data interpretation.
*   **Fee Payer:** The first entry in `signedAddresses` is the fee payer. Logic for deducting fees must correctly and exclusively identify this address.

## Copyright

This LIP is licensed under the MIT License, in alignment with the main [LEA Project](https://getlea.org) License.
